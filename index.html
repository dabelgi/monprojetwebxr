<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle Assistant AR - Quest 2</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Sora:wght@400;600;700&family=JetBrains+Mono:wght@400;600&display=swap');

        :root {
            --bg-1: #0b0f1d;
            --bg-2: #121a2b;
            --panel: rgba(16, 24, 44, 0.82);
            --panel-strong: rgba(20, 30, 52, 0.94);
            --stroke: rgba(96, 120, 160, 0.35);
            --accent: #32f5a6;
            --accent-2: #4bb7ff;
            --accent-3: #ff7a59;
            --text: #f2f6ff;
            --muted: #a5b1c6;
            --danger: #ff5f7e;
            --glow: 0 18px 46px rgba(50, 245, 166, 0.18);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: radial-gradient(circle at top, rgba(75, 183, 255, 0.08), transparent 45%),
                        linear-gradient(160deg, var(--bg-1), var(--bg-2));
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background: linear-gradient(120deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                        linear-gradient(60deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
            background-size: 80px 80px, 120px 120px;
            pointer-events: none;
            opacity: 0.4;
            z-index: 0;
        }

        main {
            position: relative;
            z-index: 1;
            max-width: 1100px;
            margin: 0 auto;
            padding: 40px 24px 80px;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        header {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        h1 {
            font-family: 'Sora', sans-serif;
            font-size: clamp(2.4rem, 2.6vw, 3.4rem);
            font-weight: 700;
            letter-spacing: -0.02em;
            color: var(--text);
            text-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
        }

        .subtitle {
            color: var(--muted);
            font-size: 1rem;
        }

        .stepper {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 10px;
        }

        .step-pill {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 10px 16px;
            border-radius: 999px;
            background: rgba(50, 245, 166, 0.12);
            border: 1px solid rgba(50, 245, 166, 0.3);
            color: var(--accent);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .grid {
            display: grid;
            gap: 24px;
        }

        @media (min-width: 980px) {
            .grid {
                grid-template-columns: 1.1fr 0.9fr;
                align-items: start;
            }
        }

        .section {
            background: var(--panel);
            border: 1px solid var(--stroke);
            border-radius: 20px;
            padding: 24px;
            box-shadow: 0 30px 60px rgba(4, 8, 18, 0.5);
            backdrop-filter: blur(12px);
        }

        .section-title {
            font-family: 'Sora', sans-serif;
            font-size: 1.3rem;
            margin-bottom: 16px;
            color: var(--accent);
        }

        .hint {
            color: var(--muted);
            font-size: 0.95rem;
            margin-bottom: 16px;
        }

        .upload-zone {
            border: 1px dashed rgba(75, 183, 255, 0.6);
            border-radius: 18px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            align-items: flex-start;
            background: rgba(75, 183, 255, 0.08);
        }

        .upload-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        button,
        .file-upload-btn {
            font-family: 'Sora', sans-serif;
            font-size: 0.95rem;
            padding: 12px 22px;
            border-radius: 999px;
            border: 1px solid transparent;
            background: linear-gradient(135deg, var(--accent), #1cd480);
            color: #04140d;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            cursor: pointer;
            transition: all 0.25s ease;
            box-shadow: var(--glow);
        }

        button:hover,
        .file-upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 20px 50px rgba(50, 245, 166, 0.35);
        }

        button.secondary {
            background: linear-gradient(135deg, var(--accent-2), #2a7bff);
            color: #08152a;
        }

        button.ghost {
            background: transparent;
            border-color: rgba(255, 255, 255, 0.2);
            color: var(--text);
            box-shadow: none;
        }

        button.danger {
            background: linear-gradient(135deg, var(--danger), #f9416f);
            color: #1b0b15;
        }

        input[type="file"] {
            display: none;
        }

        .preview-row {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 18px;
        }

        .preview-image {
            max-width: 100%;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.35);
        }

        .cropper {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-top: 18px;
        }

        .cropper-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .cropper-canvas {
            width: 100%;
            border-radius: 16px;
            border: 1px solid rgba(50, 245, 166, 0.25);
            background: rgba(6, 10, 22, 0.8);
        }

        .crop-hint {
            font-size: 0.85rem;
            color: var(--muted);
        }

        .crop-info {
            font-size: 0.9rem;
            color: var(--accent);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 18px;
        }

        .control-row {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.9rem;
            color: var(--muted);
        }

        .range-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.15);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent);
            border: 2px solid #0d1b18;
            cursor: pointer;
        }

        .toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text);
        }

        .steps-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 12px;
        }

        .step {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 12px;
            align-items: center;
            padding: 12px 14px;
            border-radius: 12px;
            background: rgba(75, 183, 255, 0.08);
            border: 1px solid rgba(75, 183, 255, 0.2);
        }

        .step span {
            font-family: 'Sora', sans-serif;
            font-weight: 600;
            color: var(--accent-2);
        }

        .status {
            text-align: center;
            font-size: 0.95rem;
            color: var(--accent);
            margin-top: 18px;
            padding: 12px;
            background: rgba(50, 245, 166, 0.1);
            border-radius: 12px;
        }

        .hidden {
            display: none !important;
        }

        #ar-canvas {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            display: none;
        }

        .vr-ui {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-strong);
            border: 1px solid rgba(50, 245, 166, 0.4);
            border-radius: 18px;
            padding: 24px 30px;
            display: none;
            z-index: 1000;
            min-width: 320px;
            box-shadow: 0 30px 50px rgba(0, 0, 0, 0.5);
        }

        .vr-ui.active {
            display: block;
        }

        .vr-status {
            font-family: 'Sora', sans-serif;
            color: var(--accent);
            font-size: 1.2rem;
            text-align: center;
            margin-bottom: 14px;
        }

        .vr-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .vr-controls button {
            font-size: 0.8rem;
            padding: 10px 18px;
        }
    </style>
</head>
<body>
    <main id="ui-container">
        <header>
            <h1>Puzzle Assistant AR</h1>
            <p class="subtitle">Optimisé pour Quest 2. Recadrage intelligent, tri des pièces en rab, et guidage AR plus propre.</p>
            <div class="stepper">
                <div class="step-pill">Étape 1 · Référence</div>
                <div class="step-pill">Étape 2 · AR & analyse</div>
            </div>
        </header>

        <div class="grid">
            <section id="step1" class="section">
                <div class="section-title">Étape 1 · Photo du puzzle</div>
                <p class="hint">Importez la photo du puzzle terminé. Vous pouvez recadrer une zone précise si le puzzle est incomplet.</p>

                <div class="upload-zone">
                    <div class="upload-actions">
                        <input type="file" id="referenceUpload" accept="image/*">
                        <label for="referenceUpload" class="file-upload-btn">Choisir une image</label>
                        <button id="confirmReference" class="secondary" disabled>Confirmer la référence</button>
                    </div>
                    <p class="crop-hint">Astuce: choisissez un cadrage net, lumière uniforme, et peu de reflets.</p>
                </div>

                <div id="referencePreview" class="preview-row hidden">
                    <img id="referenceImg" class="preview-image" alt="Référence puzzle">

                    <div class="cropper">
                        <div class="cropper-toolbar">
                            <button id="useFullBtn" class="ghost">Utiliser l'image complète</button>
                            <button id="resetCropBtn" class="ghost">Redéfinir le cadre</button>
                        </div>
                        <canvas id="cropCanvas" class="cropper-canvas" height="300"></canvas>
                        <div class="crop-hint">Cliquez-glissez pour dessiner la zone à analyser.</div>
                        <div id="cropInfo" class="crop-info">Zone active: image complète</div>
                        <button id="applyCropBtn">Utiliser cette zone</button>
                    </div>

                    <img id="croppedPreview" class="preview-image hidden" alt="Zone utilisée">
                </div>
            </section>

            <section id="step2" class="section hidden">
                <div class="section-title">Étape 2 · Analyse AR</div>
                <div class="steps-list">
                    <div class="step"><span>1</span>Placez-vous devant votre puzzle et les pièces restantes.</div>
                    <div class="step"><span>2</span>Appuyez sur Démarrer AR et acceptez l'accès.</div>
                    <div class="step"><span>3</span>Dans l'AR, scannez puis analysez pour voir les placements.</div>
                </div>

                <div class="control-group">
                    <div class="control-row">
                        Pièces en rab estimées
                        <div class="range-row">
                            <input type="range" id="extraPieces" min="0" max="60" value="35">
                            <span id="extraPiecesValue">35%</span>
                        </div>
                    </div>
                    <div class="control-row">
                        Tolérance du filtre couleur (plus strict = moins de faux positifs)
                        <div class="range-row">
                            <input type="range" id="colorTolerance" min="0" max="100" value="30">
                            <span id="colorToleranceValue">Strict</span>
                        </div>
                    </div>
                    <label class="toggle">
                        <input type="checkbox" id="filterEnabled" checked>
                        Ignorer les pièces hors palette
                    </label>
                </div>

                <div style="margin-top: 22px; display: flex; gap: 12px; flex-wrap: wrap;">
                    <button id="startAR">Démarrer AR</button>
                    <button id="scanOnlyBtn" class="ghost">Scanner seulement</button>
                </div>

                <div id="status" class="status hidden"></div>
            </section>
        </div>
    </main>

    <div id="vrUI" class="vr-ui">
        <div class="vr-status" id="vrStatus">Prêt à scanner</div>
        <div class="vr-controls">
            <button id="scanBtn">Scanner</button>
            <button id="analyzeBtn" class="secondary">Analyser</button>
            <button id="resetBtn" class="danger">Reset</button>
            <button id="exitBtn" class="ghost">Quitter</button>
        </div>
    </div>

    <canvas id="ar-canvas"></canvas>

    <script type="module">
        const appState = {
            referenceImage: null,
            referenceImageData: null,
            referenceFullImageData: null,
            referenceSize: null,
            crop: null,
            palette: [],
            inAR: false,
            pieces: [],
            scanned: false,
            analyzed: false
        };

        const step1 = document.getElementById('step1');
        const step2 = document.getElementById('step2');
        const referenceUpload = document.getElementById('referenceUpload');
        const referencePreview = document.getElementById('referencePreview');
        const referenceImg = document.getElementById('referenceImg');
        const confirmReference = document.getElementById('confirmReference');
        const startARBtn = document.getElementById('startAR');
        const scanOnlyBtn = document.getElementById('scanOnlyBtn');
        const statusDiv = document.getElementById('status');
        const uiContainer = document.getElementById('ui-container');
        const vrUI = document.getElementById('vrUI');
        const vrStatus = document.getElementById('vrStatus');
        const canvas = document.getElementById('ar-canvas');
        const gl = canvas.getContext('webgl2', { xrCompatible: true });

        const scanBtn = document.getElementById('scanBtn');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const resetBtn = document.getElementById('resetBtn');
        const exitBtn = document.getElementById('exitBtn');

        const cropCanvas = document.getElementById('cropCanvas');
        const cropCtx = cropCanvas.getContext('2d');
        const cropInfo = document.getElementById('cropInfo');
        const applyCropBtn = document.getElementById('applyCropBtn');
        const useFullBtn = document.getElementById('useFullBtn');
        const resetCropBtn = document.getElementById('resetCropBtn');
        const croppedPreview = document.getElementById('croppedPreview');

        const extraPieces = document.getElementById('extraPieces');
        const extraPiecesValue = document.getElementById('extraPiecesValue');
        const colorTolerance = document.getElementById('colorTolerance');
        const colorToleranceValue = document.getElementById('colorToleranceValue');
        const filterEnabled = document.getElementById('filterEnabled');

        let xrSession = null;
        let xrRefSpace = null;
        let activeImageUrl = null;

        const cropState = {
            img: null,
            rect: null,
            drawing: false,
            startX: 0,
            startY: 0,
            scale: 1,
            offsetX: 0,
            offsetY: 0
        };

        if (!gl) {
            showStatus('WebGL2 indisponible: la vue AR ne pourra pas démarrer.', true);
        }

        referenceUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            if (activeImageUrl) {
                URL.revokeObjectURL(activeImageUrl);
            }

            activeImageUrl = URL.createObjectURL(file);
            const img = new Image();
            img.onload = () => {
                appState.referenceImage = activeImageUrl;
                referenceImg.src = activeImageUrl;
                referencePreview.classList.remove('hidden');
                confirmReference.disabled = false;

                prepareReferenceData(img);
                setupCropper(img);
            };
            img.src = activeImageUrl;
        });

        confirmReference.addEventListener('click', () => {
            step1.classList.add('hidden');
            step2.classList.remove('hidden');
            showStatus('Référence enregistrée. Prêt pour l\'analyse AR.');
        });

        useFullBtn.addEventListener('click', () => {
            if (!appState.referenceFullImageData) return;
            appState.referenceImageData = appState.referenceFullImageData;
            appState.referenceSize = {
                width: appState.referenceFullImageData.width,
                height: appState.referenceFullImageData.height
            };
            appState.crop = null;
            appState.palette = buildPalette(appState.referenceImageData);
            cropInfo.textContent = 'Zone active: image complète';
            croppedPreview.classList.add('hidden');
            drawCropCanvas();
        });

        resetCropBtn.addEventListener('click', () => {
            cropState.rect = null;
            cropInfo.textContent = 'Zone active: image complète';
            croppedPreview.classList.add('hidden');
            drawCropCanvas();
        });

        applyCropBtn.addEventListener('click', () => {
            if (!cropState.rect || !cropState.img) return;
            const { x, y, w, h } = cropState.rect;
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = w;
            tempCanvas.height = h;
            const ctx = tempCanvas.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(cropState.img, x, y, w, h, 0, 0, w, h);
            appState.referenceImageData = ctx.getImageData(0, 0, w, h);
            appState.referenceSize = { width: w, height: h };
            appState.crop = { x, y, w, h };
            appState.palette = buildPalette(appState.referenceImageData);

            croppedPreview.src = tempCanvas.toDataURL('image/png');
            croppedPreview.classList.remove('hidden');
            cropInfo.textContent = `Zone active: ${Math.round(w)}x${Math.round(h)} px`;
        });

        cropCanvas.addEventListener('pointerdown', (event) => {
            if (!cropState.img) return;
            const pos = getCanvasPosition(event);
            cropState.drawing = true;
            cropState.startX = pos.x;
            cropState.startY = pos.y;
            cropState.rect = { x: pos.x, y: pos.y, w: 0, h: 0 };
            drawCropCanvas();
        });

        window.addEventListener('pointermove', (event) => {
            if (!cropState.drawing) return;
            const pos = getCanvasPosition(event);
            const x = Math.min(cropState.startX, pos.x);
            const y = Math.min(cropState.startY, pos.y);
            const w = Math.abs(pos.x - cropState.startX);
            const h = Math.abs(pos.y - cropState.startY);
            cropState.rect = { x, y, w, h };
            drawCropCanvas();
        });

        window.addEventListener('pointerup', () => {
            if (!cropState.drawing) return;
            cropState.drawing = false;
            if (cropState.rect && (cropState.rect.w < 20 || cropState.rect.h < 20)) {
                cropState.rect = null;
                cropInfo.textContent = 'Zone active: image complète';
            } else if (cropState.rect) {
                cropInfo.textContent = `Zone prête: ${Math.round(cropState.rect.w)}x${Math.round(cropState.rect.h)} px`;
            }
            drawCropCanvas();
        });

        startARBtn.addEventListener('click', async () => {
            if (!navigator.xr) {
                showStatus('WebXR non disponible sur ce navigateur.', true);
                return;
            }

            try {
                showStatus('Initialisation AR...');
                const supported = await navigator.xr.isSessionSupported('immersive-ar');
                if (!supported) {
                    showStatus('AR non supporté sur cet appareil.', true);
                    return;
                }

                xrSession = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['local-floor'],
                    optionalFeatures: ['hand-tracking', 'hit-test']
                });

                await onSessionStarted();
            } catch (error) {
                console.error('Erreur AR:', error);
                showStatus(`Erreur: ${error.message}`, true);
            }
        });

        scanOnlyBtn.addEventListener('click', () => {
            if (!appState.referenceImageData) {
                showStatus('Ajoutez une image de référence avant le scan.', true);
                return;
            }
            handleScan();
        });

        async function onSessionStarted() {
            appState.inAR = true;

            if (gl) {
                await gl.makeXRCompatible();
                xrSession.updateRenderState({
                    baseLayer: new XRWebGLLayer(xrSession, gl)
                });
            }

            xrRefSpace = await xrSession.requestReferenceSpace('local-floor');

            uiContainer.classList.add('hidden');
            canvas.style.display = 'block';
            vrUI.classList.add('active');

            resizeGLCanvas();
            window.addEventListener('resize', resizeGLCanvas);

            initShaders();

            xrSession.requestAnimationFrame(onXRFrame);
            xrSession.addEventListener('end', onSessionEnded);

            updateVRStatus('Pointez vers vos pièces et cliquez Scanner');
        }

        function onSessionEnded() {
            appState.inAR = false;
            xrSession = null;

            uiContainer.classList.remove('hidden');
            canvas.style.display = 'none';
            vrUI.classList.remove('active');

            showStatus('Session AR terminée.');
        }

        scanBtn.addEventListener('click', handleScan);
        analyzeBtn.addEventListener('click', handleAnalyze);
        resetBtn.addEventListener('click', handleReset);
        exitBtn.addEventListener('click', () => {
            if (xrSession) {
                xrSession.end();
            }
        });

        function handleScan() {
            if (!appState.referenceImageData) {
                updateVRStatus('Ajoutez une référence avant de scanner.');
                showStatus('Ajoutez une image de référence avant le scan.', true);
                return;
            }

            updateVRStatus('Scan en cours...');
            showStatus('Scan en cours...');

            setTimeout(() => {
                const baseCount = Math.floor(Math.random() * 5) + 8;
                const extraRate = parseInt(extraPieces.value, 10) / 100;
                const extraCount = Math.round(baseCount * extraRate);
                const keepCount = Math.max(1, baseCount - extraCount);
                const palette = appState.palette.length ? appState.palette : [[0.2, 0.8, 0.6]];

                const flags = [];
                for (let i = 0; i < baseCount; i++) {
                    flags.push(i < extraCount);
                }
                shuffleArray(flags);

                const generated = [];
                for (let i = 0; i < baseCount; i++) {
                    const isExtra = flags[i];
                    const color = isExtra ? randomColor() : jitterColor(palette[Math.floor(Math.random() * palette.length)], 0.12);
                    const angle = (i / baseCount) * Math.PI * 2;
                    const radius = 0.45 + Math.random() * 0.12;

                    generated.push({
                        id: i + 1,
                        position: [
                            Math.cos(angle) * radius,
                            0.2,
                            -1 + Math.sin(angle) * radius
                        ],
                        color,
                        targetPosition: null,
                        extra: isExtra
                    });
                }

                let filtered = generated;
                let removed = 0;
                if (filterEnabled.checked && appState.palette.length) {
                    const threshold = getColorThreshold();
                    filtered = generated.filter((piece) => colorDistanceToPalette(piece.color, appState.palette) <= threshold);
                    removed = generated.length - filtered.length;
                }

                appState.pieces = filtered;
                appState.scanned = true;
                appState.analyzed = false;

                const retainedCount = appState.pieces.length;
                const removedInfo = removed ? ` (${removed} écartées)` : '';
                updateVRStatus(`Scan terminé: ${retainedCount} pièces retenues${removedInfo}.`);
                showStatus(`Scan terminé: ${retainedCount} pièces retenues${removedInfo}.`);
            }, 1400);
        }

        function handleAnalyze() {
            if (!appState.scanned) {
                updateVRStatus('Scannez d\'abord les pièces.');
                return;
            }
            if (!appState.pieces.length) {
                updateVRStatus('Aucune pièce retenue. Assouplissez le filtre.');
                showStatus('Aucune pièce retenue. Assouplissez le filtre.', true);
                return;
            }

            updateVRStatus('Analyse des placements...');
            showStatus('Analyse des placements...');

            setTimeout(() => {
                assignTargetPositions(appState.pieces);
                appState.analyzed = true;
                updateVRStatus('Placements calculés. Suivez les flèches AR.');
                showStatus('Placements calculés. Suivez les flèches AR.');
            }, 1400);
        }

        function handleReset() {
            appState.pieces = [];
            appState.scanned = false;
            appState.analyzed = false;
            updateVRStatus('Reset effectué. Cliquez Scanner.');
            showStatus('Reset effectué.');
        }

        function updateVRStatus(text) {
            vrStatus.textContent = text;
        }

        function showStatus(text, isError = false) {
            statusDiv.textContent = text;
            statusDiv.style.color = isError ? 'var(--danger)' : 'var(--accent)';
            statusDiv.classList.remove('hidden');
        }

        function resizeGLCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function prepareReferenceData(img) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = img.naturalWidth;
            tempCanvas.height = img.naturalHeight;
            const ctx = tempCanvas.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(img, 0, 0);
            appState.referenceFullImageData = ctx.getImageData(0, 0, img.naturalWidth, img.naturalHeight);
            appState.referenceImageData = appState.referenceFullImageData;
            appState.referenceSize = { width: img.naturalWidth, height: img.naturalHeight };
            appState.crop = null;
            appState.palette = buildPalette(appState.referenceImageData);
            cropInfo.textContent = 'Zone active: image complète';
        }

        function setupCropper(img) {
            cropState.img = img;
            cropState.rect = null;
            resizeCropCanvas();
            drawCropCanvas();
        }

        function resizeCropCanvas() {
            const maxWidth = cropCanvas.parentElement.clientWidth;
            const aspect = cropState.img ? cropState.img.naturalWidth / cropState.img.naturalHeight : 1;
            cropCanvas.width = maxWidth;
            cropCanvas.height = Math.min(360, Math.max(220, maxWidth / aspect));
        }

        window.addEventListener('resize', () => {
            if (!cropState.img) return;
            resizeCropCanvas();
            drawCropCanvas();
        });

        function drawCropCanvas() {
            if (!cropState.img) return;
            const img = cropState.img;
            const canvasWidth = cropCanvas.width;
            const canvasHeight = cropCanvas.height;

            const scale = Math.min(canvasWidth / img.naturalWidth, canvasHeight / img.naturalHeight);
            cropState.scale = scale;
            cropState.offsetX = (canvasWidth - img.naturalWidth * scale) / 2;
            cropState.offsetY = (canvasHeight - img.naturalHeight * scale) / 2;

            cropCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            cropCtx.drawImage(img, cropState.offsetX, cropState.offsetY, img.naturalWidth * scale, img.naturalHeight * scale);

            if (cropState.rect) {
                const rect = cropState.rect;
                const drawX = cropState.offsetX + rect.x * scale;
                const drawY = cropState.offsetY + rect.y * scale;
                const drawW = rect.w * scale;
                const drawH = rect.h * scale;

                cropCtx.fillStyle = 'rgba(4, 8, 18, 0.55)';
                cropCtx.fillRect(0, 0, canvasWidth, canvasHeight);

                cropCtx.globalCompositeOperation = 'destination-out';
                cropCtx.fillRect(drawX, drawY, drawW, drawH);
                cropCtx.globalCompositeOperation = 'source-over';

                cropCtx.strokeStyle = 'rgba(50, 245, 166, 0.9)';
                cropCtx.lineWidth = 2;
                cropCtx.strokeRect(drawX, drawY, drawW, drawH);
            }
        }

        function getCanvasPosition(event) {
            const rect = cropCanvas.getBoundingClientRect();
            const x = (event.clientX - rect.left - cropState.offsetX) / cropState.scale;
            const y = (event.clientY - rect.top - cropState.offsetY) / cropState.scale;
            const clampedX = clamp(x, 0, cropState.img.naturalWidth);
            const clampedY = clamp(y, 0, cropState.img.naturalHeight);
            return { x: clampedX, y: clampedY };
        }

        function buildPalette(imageData) {
            const { data } = imageData;
            const bins = new Map();
            const step = 8;
            const bucketSize = 32;

            for (let i = 0; i < data.length; i += 4 * step) {
                const alpha = data[i + 3];
                if (alpha < 200) continue;
                const r = Math.round(data[i] / bucketSize) * bucketSize;
                const g = Math.round(data[i + 1] / bucketSize) * bucketSize;
                const b = Math.round(data[i + 2] / bucketSize) * bucketSize;
                const key = `${r}|${g}|${b}`;

                if (!bins.has(key)) {
                    bins.set(key, { count: 0, sum: [0, 0, 0] });
                }
                const bin = bins.get(key);
                bin.count += 1;
                bin.sum[0] += data[i];
                bin.sum[1] += data[i + 1];
                bin.sum[2] += data[i + 2];
            }

            const palette = Array.from(bins.values())
                .sort((a, b) => b.count - a.count)
                .slice(0, 6)
                .map((bin) => [
                    bin.sum[0] / bin.count / 255,
                    bin.sum[1] / bin.count / 255,
                    bin.sum[2] / bin.count / 255
                ]);

            return palette.length ? palette : [[0.2, 0.8, 0.6]];
        }

        function colorDistanceToPalette(color, palette) {
            let min = Infinity;
            for (const ref of palette) {
                const dist = Math.sqrt(
                    Math.pow(color[0] - ref[0], 2) +
                    Math.pow(color[1] - ref[1], 2) +
                    Math.pow(color[2] - ref[2], 2)
                );
                if (dist < min) min = dist;
            }
            return min;
        }

        function getColorThreshold() {
            const value = parseInt(colorTolerance.value, 10);
            return 0.18 + (value / 100) * 0.6;
        }

        function assignTargetPositions(pieces) {
            const total = pieces.length;
            const aspect = appState.referenceSize ? appState.referenceSize.width / appState.referenceSize.height : 1;
            const cols = Math.max(1, Math.ceil(Math.sqrt(total * aspect)));
            const rows = Math.ceil(total / cols);
            const spacing = 0.12;
            const startX = -((cols - 1) * spacing) / 2;
            const startZ = -1.6 - ((rows - 1) * spacing) / 2;

            pieces.forEach((piece, index) => {
                const row = Math.floor(index / cols);
                const col = index % cols;
                piece.targetPosition = [
                    startX + col * spacing,
                    0.2,
                    startZ + row * spacing
                ];
            });
        }

        function randomColor() {
            return [Math.random(), Math.random(), Math.random()];
        }

        function jitterColor(color, amount) {
            return color.map((channel) => clamp(channel + (Math.random() * 2 - 1) * amount, 0, 1));
        }

        function clamp(value, min, max) {
            return Math.min(max, Math.max(min, value));
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        extraPieces.addEventListener('input', () => {
            extraPiecesValue.textContent = `${extraPieces.value}%`;
        });

        colorTolerance.addEventListener('input', () => {
            const value = parseInt(colorTolerance.value, 10);
            let label = 'Équilibré';
            if (value < 30) label = 'Strict';
            if (value > 70) label = 'Tolérant';
            colorToleranceValue.textContent = label;
        });

        function onXRFrame(time, frame) {
            const session = frame.session;
            session.requestAnimationFrame(onXRFrame);
            if (!gl) return;

            const pose = frame.getViewerPose(xrRefSpace);
            if (!pose) return;

            const layer = session.renderState.baseLayer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, layer.framebuffer);
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            for (const view of pose.views) {
                const viewport = layer.getViewport(view);
                gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
                renderScene(view);
            }
        }

        function renderScene(view) {
            if (!gl.program) return;

            const projMatrix = view.projectionMatrix;
            const viewMatrix = view.transform.inverse.matrix;

            appState.pieces.forEach((piece) => {
                drawSphere(piece.position, [0.1, 1, 0.6], 0.06, projMatrix, viewMatrix);

                if (appState.analyzed && piece.targetPosition) {
                    drawSphere(piece.targetPosition, [1, 0.3, 0.4], 0.06, projMatrix, viewMatrix);
                    drawLine(piece.position, piece.targetPosition, piece.color, projMatrix, viewMatrix);
                    const arrowPos = [
                        piece.targetPosition[0],
                        piece.targetPosition[1] + 0.18,
                        piece.targetPosition[2]
                    ];
                    drawSphere(arrowPos, [0.2, 0.9, 1], 0.04, projMatrix, viewMatrix);
                }
            });
        }

        function initShaders() {
            if (!gl) return;
            const vertexShaderSource = `
                attribute vec3 position;
                uniform mat4 projection;
                uniform mat4 view;
                uniform mat4 model;

                void main() {
                    gl_Position = projection * view * model * vec4(position, 1.0);
                    gl_PointSize = 28.0;
                }
            `;

            const fragmentShaderSource = `
                precision mediump float;
                uniform vec3 color;

                void main() {
                    vec2 coord = gl_PointCoord - vec2(0.5);
                    float dist = length(coord);
                    if (dist > 0.5) discard;

                    float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
                    gl_FragColor = vec4(color, alpha * 0.9);
                }
            `;

            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexShaderSource);
            gl.compileShader(vertexShader);

            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentShaderSource);
            gl.compileShader(fragmentShader);

            gl.program = gl.createProgram();
            gl.attachShader(gl.program, vertexShader);
            gl.attachShader(gl.program, fragmentShader);
            gl.linkProgram(gl.program);

            gl.buffer = gl.createBuffer();
        }

        function drawSphere(position, color, radius, projMatrix, viewMatrix) {
            if (!gl.program) return;

            gl.useProgram(gl.program);

            const posLoc = gl.getAttribLocation(gl.program, 'position');
            const colorLoc = gl.getUniformLocation(gl.program, 'color');
            const projLoc = gl.getUniformLocation(gl.program, 'projection');
            const viewLoc = gl.getUniformLocation(gl.program, 'view');
            const modelLoc = gl.getUniformLocation(gl.program, 'model');

            const modelMatrix = new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                position[0], position[1], position[2], 1
            ]);

            gl.uniformMatrix4fv(projLoc, false, projMatrix);
            gl.uniformMatrix4fv(viewLoc, false, viewMatrix);
            gl.uniformMatrix4fv(modelLoc, false, modelMatrix);
            gl.uniform3fv(colorLoc, color);

            gl.bindBuffer(gl.ARRAY_BUFFER, gl.buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0]), gl.STATIC_DRAW);
            gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(posLoc);

            gl.drawArrays(gl.POINTS, 0, 1);
        }

        function drawLine(start, end, color, projMatrix, viewMatrix) {
            if (!gl.program) return;

            gl.useProgram(gl.program);

            const posLoc = gl.getAttribLocation(gl.program, 'position');
            const colorLoc = gl.getUniformLocation(gl.program, 'color');
            const projLoc = gl.getUniformLocation(gl.program, 'projection');
            const viewLoc = gl.getUniformLocation(gl.program, 'view');
            const modelLoc = gl.getUniformLocation(gl.program, 'model');

            const identity = new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);

            gl.uniformMatrix4fv(projLoc, false, projMatrix);
            gl.uniformMatrix4fv(viewLoc, false, viewMatrix);
            gl.uniformMatrix4fv(modelLoc, false, identity);
            gl.uniform3fv(colorLoc, color);

            gl.bindBuffer(gl.ARRAY_BUFFER, gl.buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                start[0], start[1], start[2],
                end[0], end[1], end[2]
            ]), gl.STATIC_DRAW);

            gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(posLoc);

            gl.drawArrays(gl.LINES, 0, 2);
        }
    </script>
</body>
</html>
