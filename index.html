<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle Assistant AR - Quest 2</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Space+Mono:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Space Mono', monospace;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1e3f 100%);
            color: white;
            overflow-x: hidden;
        }
        
        #ui-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            background: linear-gradient(135deg, #00ff88, #00b8ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .section {
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 30px;
            margin: 20px 0;
            max-width: 700px;
            width: 100%;
        }
        
        .section-title {
            font-family: 'Orbitron', sans-serif;
            color: #00ff88;
            font-size: 1.5rem;
            margin-bottom: 20px;
            text-transform: uppercase;
        }
        
        .step {
            background: rgba(0, 184, 255, 0.1);
            border: 1px solid #00b8ff;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
        }
        
        button {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            padding: 15px 40px;
            margin: 10px;
            background: linear-gradient(135deg, #00ff88, #00cc6f);
            color: #0a0e27;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.4);
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(0, 255, 136, 0.6);
        }
        
        button.secondary {
            background: linear-gradient(135deg, #00b8ff, #0088cc);
        }
        
        input[type="file"] {
            display: none;
        }
        
        .file-upload-btn {
            display: inline-block;
            padding: 15px 30px;
            background: linear-gradient(135deg, #ff0080, #cc0066);
            color: white;
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            text-transform: uppercase;
            margin: 10px;
            transition: all 0.3s ease;
        }
        
        .file-upload-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(255, 0, 128, 0.4);
        }
        
        .preview-image {
            max-width: 300px;
            margin: 15px auto;
            border: 2px solid #00ff88;
            border-radius: 10px;
            display: block;
        }
        
        .status {
            text-align: center;
            font-size: 1.1rem;
            color: #00ff88;
            margin: 15px 0;
            padding: 10px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 10px;
        }
        
        .hidden {
            display: none !important;
        }
        
        #ar-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
        }
        
        /* UI in VR */
        .vr-ui {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 14, 39, 0.95);
            border: 3px solid #00ff88;
            border-radius: 20px;
            padding: 30px;
            display: none;
            z-index: 1000;
            min-width: 400px;
        }
        
        .vr-ui.active {
            display: block;
        }
        
        .vr-status {
            font-family: 'Orbitron', sans-serif;
            color: #00ff88;
            font-size: 1.5rem;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .vr-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .vr-controls button {
            font-size: 1rem;
            padding: 12px 25px;
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <h1>üß© Puzzle Assistant AR</h1>
        
        <!-- √âtape 1: Upload photo r√©f√©rence -->
        <div id="step1" class="section">
            <div class="section-title">üì∏ √âtape 1: Photo du Puzzle Complet</div>
            <p style="margin-bottom: 20px;">Uploadez une photo du puzzle termin√© (ou de la bo√Æte)</p>
            
            <input type="file" id="referenceUpload" accept="image/*">
            <label for="referenceUpload" class="file-upload-btn">üì§ Choisir une image</label>
            
            <div id="referencePreview" class="hidden">
                <img id="referenceImg" class="preview-image" alt="Puzzle complet">
                <button id="confirmReference">‚úì Confirmer l'image</button>
            </div>
        </div>
        
        <!-- √âtape 2: Instructions AR -->
        <div id="step2" class="section hidden">
            <div class="section-title">ü•Ω √âtape 2: Entrer en mode AR</div>
            
            <div class="step">
                <strong>1.</strong> Positionnez-vous devant votre puzzle avec les pi√®ces restantes
            </div>
            <div class="step">
                <strong>2.</strong> Cliquez sur "D√©marrer AR" ci-dessous
            </div>
            <div class="step">
                <strong>3.</strong> Autorisez l'acc√®s AR quand demand√©
            </div>
            <div class="step">
                <strong>4.</strong> Dans la VR, utilisez les contr√¥leurs pour :
                <ul style="margin-left: 30px; margin-top: 10px;">
                    <li>Pointer et cliquer sur "SCANNER" pour d√©tecter les pi√®ces</li>
                    <li>Cliquer sur "ANALYSER" pour voir les placements</li>
                </ul>
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button id="startAR">üöÄ D√©marrer AR</button>
            </div>
        </div>
        
        <div id="status" class="status hidden"></div>
    </div>
    
    <!-- VR UI Overlay -->
    <div id="vrUI" class="vr-ui">
        <div class="vr-status" id="vrStatus">Pr√™t √† scanner</div>
        <div class="vr-controls">
            <button id="scanBtn">üì∏ SCANNER</button>
            <button id="analyzeBtn" class="secondary">üîç ANALYSER</button>
            <button id="resetBtn" style="background: #ff0080;">üîÑ RESET</button>
            <button id="exitBtn" style="background: #666;">‚ùå QUITTER</button>
        </div>
    </div>

    <canvas id="ar-canvas"></canvas>

    <script type="module">
        // √âtat global
        const appState = {
            referenceImage: null,
            referenceImageData: null,
            inAR: false,
            pieces: [],
            scanned: false,
            analyzed: false
        };
        
        // √âl√©ments DOM
        const step1 = document.getElementById('step1');
        const step2 = document.getElementById('step2');
        const referenceUpload = document.getElementById('referenceUpload');
        const referencePreview = document.getElementById('referencePreview');
        const referenceImg = document.getElementById('referenceImg');
        const confirmReference = document.getElementById('confirmReference');
        const startARBtn = document.getElementById('startAR');
        const statusDiv = document.getElementById('status');
        const uiContainer = document.getElementById('ui-container');
        const vrUI = document.getElementById('vrUI');
        const vrStatus = document.getElementById('vrStatus');
        const canvas = document.getElementById('ar-canvas');
        const gl = canvas.getContext('webgl2', { xrCompatible: true });
        
        // Boutons VR
        const scanBtn = document.getElementById('scanBtn');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const resetBtn = document.getElementById('resetBtn');
        const exitBtn = document.getElementById('exitBtn');
        
        let xrSession = null;
        let xrRefSpace = null;
        let animationFrameId = null;
        
        // √âTAPE 1: Upload de la photo de r√©f√©rence
        referenceUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    appState.referenceImage = event.target.result;
                    referenceImg.src = event.target.result;
                    referencePreview.classList.remove('hidden');
                    
                    // Analyser l'image
                    analyzeReferenceImage(event.target.result);
                };
                reader.readAsDataURL(file);
            }
        });
        
        confirmReference.addEventListener('click', () => {
            step1.classList.add('hidden');
            step2.classList.remove('hidden');
            showStatus('‚úì Image de r√©f√©rence enregistr√©e !');
        });
        
        function analyzeReferenceImage(imageSrc) {
            const img = new Image();
            img.onload = () => {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = img.width;
                tempCanvas.height = img.height;
                const ctx = tempCanvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                appState.referenceImageData = ctx.getImageData(0, 0, img.width, img.height);
            };
            img.src = imageSrc;
        }
        
        // √âTAPE 2: D√©marrer AR
        startARBtn.addEventListener('click', async () => {
            try {
                showStatus('Initialisation AR...');
                
                const supported = await navigator.xr.isSessionSupported('immersive-ar');
                if (!supported) {
                    showStatus('‚ùå AR non support√© sur cet appareil', true);
                    return;
                }
                
                xrSession = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['local-floor'],
                    optionalFeatures: ['hand-tracking', 'hit-test']
                });
                
                await onSessionStarted();
                
            } catch (error) {
                console.error('Erreur AR:', error);
                showStatus('‚ùå Erreur: ' + error.message, true);
            }
        });
        
        async function onSessionStarted() {
            appState.inAR = true;
            
            await gl.makeXRCompatible();
            xrSession.updateRenderState({
                baseLayer: new XRWebGLLayer(xrSession, gl)
            });
            
            xrRefSpace = await xrSession.requestReferenceSpace('local-floor');
            
            // Masquer UI normale, afficher UI VR
            uiContainer.classList.add('hidden');
            canvas.style.display = 'block';
            vrUI.classList.add('active');
            
            initShaders();
            
            xrSession.requestAnimationFrame(onXRFrame);
            xrSession.addEventListener('end', onSessionEnded);
            
            updateVRStatus('Pointez vers vos pi√®ces et cliquez SCANNER');
        }
        
        function onSessionEnded() {
            appState.inAR = false;
            xrSession = null;
            
            uiContainer.classList.remove('hidden');
            canvas.style.display = 'none';
            vrUI.classList.remove('active');
            
            showStatus('Session AR termin√©e');
        }
        
        // Boutons de contr√¥le VR
        scanBtn.addEventListener('click', handleScan);
        analyzeBtn.addEventListener('click', handleAnalyze);
        resetBtn.addEventListener('click', handleReset);
        exitBtn.addEventListener('click', () => {
            if (xrSession) {
                xrSession.end();
            }
        });
        
        function handleScan() {
            updateVRStatus('üì∏ Scan en cours...');
            
            setTimeout(() => {
                // G√©n√©rer des pi√®ces d√©tect√©es (simulation)
                const numPieces = Math.floor(Math.random() * 5) + 4;
                appState.pieces = [];
                
                for (let i = 0; i < numPieces; i++) {
                    const angle = (i / numPieces) * Math.PI * 2;
                    const radius = 0.4;
                    
                    appState.pieces.push({
                        id: i + 1,
                        position: [
                            Math.cos(angle) * radius,
                            0.2,
                            -1 + Math.sin(angle) * radius
                        ],
                        color: [
                            Math.random(),
                            0.5 + Math.random() * 0.5,
                            0.7 + Math.random() * 0.3
                        ],
                        targetPosition: null
                    });
                }
                
                appState.scanned = true;
                updateVRStatus(`‚úì ${numPieces} pi√®ces d√©tect√©es ! Cliquez ANALYSER`);
            }, 2000);
        }
        
        function handleAnalyze() {
            if (!appState.scanned) {
                updateVRStatus('‚ö†Ô∏è Scannez d\'abord les pi√®ces !');
                return;
            }
            
            updateVRStatus('üîç Analyse des placements...');
            
            setTimeout(() => {
                // Calculer les positions cibles
                appState.pieces.forEach((piece, i) => {
                    const targetAngle = (i / appState.pieces.length) * Math.PI * 2 + Math.PI;
                    const targetRadius = 0.3;
                    
                    piece.targetPosition = [
                        Math.cos(targetAngle) * targetRadius,
                        0.2,
                        -1.5 + Math.sin(targetAngle) * targetRadius
                    ];
                });
                
                appState.analyzed = true;
                updateVRStatus('‚úì Placements calcul√©s ! Suivez les fl√®ches AR');
            }, 2000);
        }
        
        function handleReset() {
            appState.pieces = [];
            appState.scanned = false;
            appState.analyzed = false;
            updateVRStatus('üîÑ Reset effectu√©. Cliquez SCANNER');
        }
        
        function updateVRStatus(text) {
            vrStatus.textContent = text;
        }
        
        function showStatus(text, isError = false) {
            statusDiv.textContent = text;
            statusDiv.style.color = isError ? '#ff0080' : '#00ff88';
            statusDiv.classList.remove('hidden');
        }
        
        // Rendu AR
        function onXRFrame(time, frame) {
            const session = frame.session;
            session.requestAnimationFrame(onXRFrame);
            
            const pose = frame.getViewerPose(xrRefSpace);
            if (!pose) return;
            
            const layer = session.renderState.baseLayer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, layer.framebuffer);
            
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            
            for (const view of pose.views) {
                const viewport = layer.getViewport(view);
                gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
                
                renderScene(view);
            }
        }
        
        function renderScene(view) {
            if (!gl.program) return;
            
            const projMatrix = view.projectionMatrix;
            const viewMatrix = view.transform.inverse.matrix;
            
            // Dessiner les marqueurs
            appState.pieces.forEach((piece) => {
                // Marqueur de position actuelle (vert)
                drawSphere(piece.position, [0, 1, 0.5], 0.06, projMatrix, viewMatrix);
                
                // Si analys√©, dessiner position cible et fl√®che
                if (appState.analyzed && piece.targetPosition) {
                    // Position cible (rouge)
                    drawSphere(piece.targetPosition, [1, 0, 0.5], 0.06, projMatrix, viewMatrix);
                    
                    // Ligne de connexion
                    drawLine(piece.position, piece.targetPosition, piece.color, projMatrix, viewMatrix);
                    
                    // Fl√®che au-dessus de la cible
                    const arrowPos = [
                        piece.targetPosition[0],
                        piece.targetPosition[1] + 0.2,
                        piece.targetPosition[2]
                    ];
                    drawSphere(arrowPos, [0, 1, 1], 0.04, projMatrix, viewMatrix);
                }
            });
        }
        
        function initShaders() {
            const vertexShaderSource = `
                attribute vec3 position;
                uniform mat4 projection;
                uniform mat4 view;
                uniform mat4 model;
                
                void main() {
                    gl_Position = projection * view * model * vec4(position, 1.0);
                    gl_PointSize = 30.0;
                }
            `;
            
            const fragmentShaderSource = `
                precision mediump float;
                uniform vec3 color;
                
                void main() {
                    vec2 coord = gl_PointCoord - vec2(0.5);
                    float dist = length(coord);
                    if (dist > 0.5) discard;
                    
                    float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
                    gl_FragColor = vec4(color, alpha * 0.9);
                }
            `;
            
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexShaderSource);
            gl.compileShader(vertexShader);
            
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentShaderSource);
            gl.compileShader(fragmentShader);
            
            gl.program = gl.createProgram();
            gl.attachShader(gl.program, vertexShader);
            gl.attachShader(gl.program, fragmentShader);
            gl.linkProgram(gl.program);
            
            gl.buffer = gl.createBuffer();
        }
        
        function drawSphere(position, color, radius, projMatrix, viewMatrix) {
            if (!gl.program) return;
            
            gl.useProgram(gl.program);
            
            const posLoc = gl.getAttribLocation(gl.program, 'position');
            const colorLoc = gl.getUniformLocation(gl.program, 'color');
            const projLoc = gl.getUniformLocation(gl.program, 'projection');
            const viewLoc = gl.getUniformLocation(gl.program, 'view');
            const modelLoc = gl.getUniformLocation(gl.program, 'model');
            
            const modelMatrix = new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                position[0], position[1], position[2], 1
            ]);
            
            gl.uniformMatrix4fv(projLoc, false, projMatrix);
            gl.uniformMatrix4fv(viewLoc, false, viewMatrix);
            gl.uniformMatrix4fv(modelLoc, false, modelMatrix);
            gl.uniform3fv(colorLoc, color);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, gl.buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0]), gl.STATIC_DRAW);
            gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(posLoc);
            
            gl.drawArrays(gl.POINTS, 0, 1);
        }
        
        function drawLine(start, end, color, projMatrix, viewMatrix) {
            if (!gl.program) return;
            
            gl.useProgram(gl.program);
            
            const posLoc = gl.getAttribLocation(gl.program, 'position');
            const colorLoc = gl.getUniformLocation(gl.program, 'color');
            const projLoc = gl.getUniformLocation(gl.program, 'projection');
            const viewLoc = gl.getUniformLocation(gl.program, 'view');
            const modelLoc = gl.getUniformLocation(gl.program, 'model');
            
            const identity = new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
            
            gl.uniformMatrix4fv(projLoc, false, projMatrix);
            gl.uniformMatrix4fv(viewLoc, false, viewMatrix);
            gl.uniformMatrix4fv(modelLoc, false, identity);
            gl.uniform3fv(colorLoc, color);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, gl.buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                start[0], start[1], start[2],
                end[0], end[1], end[2]
            ]), gl.STATIC_DRAW);
            
            gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(posLoc);
            
            gl.lineWidth(3);
            gl.drawArrays(gl.LINES, 0, 2);
        }
    </script>
</body>
</html>
